---
layout: post
title: "[db] 3 - 日志恢复"
subtitle: 
author: "Dongbo"
header-style: text
mathjax: true
hidden: false
tags:
  - database
---

> 日志恢复的笔记

### 概念[^1]

事务的原子性要求事务对数据库的修改要么能够全部成功应用，要么把已经修改的部分全部撤回，恢复到该事务执行之前的状态。但是如果在一个事务在执行过程中发生了系统崩溃，内存中的 dirty page 没有来得及写入磁盘，就可能造成数据库状态的不一致，比如教材中举的例子：A从账户中取出\\$50转到B的账户，而\\$50转出A的账户，还没写入B的账户时发生了故障。

日志恢复系统就是用于解决这一问题、保证事务的原子性的。一条日志包含以下几个字段[^1]:

- 事务ID
- 数据ID，比如要修改的Page ID和offset
- old value
- new value

可以简记为$<T_i, X_j, V_1, V_2>$，另外用$<T_i, start>$表示事务开始，$<T_i, commit>$表示事务提交，$<T_i, abort>$表示事务终止。

数据库系统开始恢复数据时，首先查看日志记录，然后重做所有已经提交的事务，撤销所有还未完成的事务。由于我们是先写日志然后再写数据库，所以如果一项修改被应用到数据库那么它肯定会出现在日志中，重做它虽然会带来额外开销但是能保证数据库状态的一致；反之，没有出现在日志中，那么它肯定也没有被应用到数据库，所以我们可以放心的撤销那些没有$<T_i, abort>$标识的事务。 // TODO：needs update


但是日志的长度会随着运行时间而不断增长，要保留所有的日志，并且每次崩溃后都要扫描整个日志来恢复数据肯定是不现实的。可以通过使用检查点来避免上述问题。可以在日志长度超过一定阈值时，向日志记录中写入一个检查点，并且将

1. 内存中所有日志
2. 内存中所有 dirty page

持久化到硬盘；检查点中还包含一个记录当前正在执行事务的列表。通过使用检查点，我们能够确定在检查点之前提交的事务，它们的修改在检查点之前、或者伴随着检查点的刷盘操作应用到数据库中，因此在恢复数据时只考虑从checkpoint到日志结尾部分的事务，重做其中已经提交的，撤销其中未完成或者终止的部分，就能保证数据库能恢复到崩溃发生前的统一状态；对于checkpoint中记录的尚未执行完毕的事务，可能需要回溯checkpoint之前的日志来对该事务进行撤销，不过一旦撤销操作完成之后，$<T_i, start>$之前的日志记录就可以被删掉了。


### 崩溃后的恢复过程


#### 使用日志重做事务

重做需要从最后一个检查点开始，扫描到日志结尾，重做日志中碰到的$<T_i, commit>和<T_j, abort>$。具体步骤如下：

1. 初始化 undo-list 为检查点中记录的事务列表；
2. 若碰到正常日志记录$<T_i, X_j, V_1, V_2>$或事务回滚产生的记录$<T_i, X_j, V_2>$，我们将重做该日志记录的修改，即将$V_2$的值赋给$X_j$；
3. 若碰到$<T_i, start>$则将事务$T_i$加入 undo-list；
4. 若碰到$<T_i, commit>或<T_i, abort>$则把事务$T_i$从 undo-list 中去掉。

当我们扫描到日志结尾，也就将所有在崩溃前已经完成的(包括commit和abort)的事务重做完毕，虽然这其中可能有些事务崩溃前已经被应用到数据库，但是我们无法确定到底哪些事务没有被应用，所以全部重做是最万无一失的方案。重做结束之后 undo-list 中将只包含那些在系统崩溃之前没有提交也没有回滚的事务，将被用于下一步的撤销操作。

#### 使用日志撤销事务

恢复的撤销阶段我们从日志末尾往前扫描，来回滚事务。具体步骤如下：

1. 遇到属于 undo-list 中事务的日志$<T_i, X_j, V_1, V_2>时，撤销该日志记录的操作，写入一条$<T_i, X_j, V_2>$的日志记录
2. 遇到属于 undo-list 中事务的$<T_i, start>$，就往日志中写入一个$<T_i, abort>$标识事务回滚完毕，并将事务从 undo-list 中删掉

上述操作进行到 undo-list 为空时，我们就完成了所有事务的回滚。

如果恢复过程再次发生崩溃，撤销过程可能把一些本来属于未完成的事务变为了abort事务，也就是需要重做的事务增加了，而需要回滚的事务减少了。

// TODO： fuzzy checkpoint

// TODO： 分布式事务

#### WAL

 WAL（Write Ahead Log） 机制是指在一次写操作被应用到数据库**之前**，需要写在日志系统中记录下这次写操作的修改并持久化到磁盘。更具体的说是*内存中的某个 dirty page 写入磁盘之前，所有与之相关的日志都必须先持久化到磁盘*。

### 延伸：InnoDB中的double write

> 其实这篇文章就是为了搞清楚什么是 partial write 以及 InnoDB 的 double write 机制才写的（因为搞不清楚为什么不能直接redo），属实是为了这点醋包的这顿饺子了。

在数据写入某个 page 的过程中发生宕机的话，可能造成部分写失效(partial write)，比如 16 KB 的页只写了前 4 KB[^2]。// TODO：与InnoDB日志、页面结构有关？ https://www.percona.com/blog/2006/08/04/innodb-double-write/

// TODO：not sure, needs update
如果是数据页面发生了 partial write，我们可以通过日志恢复机制来恢复数据；但是如果是存储日志的页面发生了 partial write，那么直接应用日志恢复就是不正确的（用了错误的日志）。

// TODO: partial write 机制介绍

### 延伸2：如何避免 partial write 问题

如果能够保证页面原子性的写入磁盘中，就不会出现 partial write。

有一些文件系统本身提供了防止 partial write 的机制，如 ZFS 文件系统[^2]


-------------

[^1]: [数据库据系统概念-第16章]()
[^2]: [MySQL技术内幕-InnoDB存储引擎](https://github.com/wususu/effective-resourses/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95(InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)%E7%AC%AC2%E7%89%88.pdf)