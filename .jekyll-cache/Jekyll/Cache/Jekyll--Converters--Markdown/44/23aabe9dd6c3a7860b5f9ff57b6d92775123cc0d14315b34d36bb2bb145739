I"(#<blockquote>
  <p>一段时间没用连之前自己写的匹配模式都看不懂了。不过本来学得也不咋地，重新学习。示例使用Java Pattern/Matcher类验证。</p>
</blockquote>

<p>这里有一份不知哪里来的<a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">正则表达式手册</a></p>

<h3 id="元字符">元字符</h3>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">^</code></td>
      <td>匹配字符串的开始位置</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">$</code></td>
      <td>匹配字符串的结束位置</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">*</code></td>
      <td>匹配前面的表达式0次或多次, “zo*“可匹配”z”, “zo”, “zoo”等, 等价于{0,}</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">+</code></td>
      <td>匹配前面的表达式1次或多次, “zo+”可匹配”zoo”, 不可匹配”z”, 等价于{1,}</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">?</code></td>
      <td>匹配前面的表达式0次或1次, “zo”可匹配”z”, “zo”, 不可匹配”zoo”, 等价于{0,1}</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">?</code></td>
      <td>(懒惰匹配)符号”?”跟在其他限制符如*, +, ?, {n}, {n,m}后时, 匹配尽可能短的字符串, 例如: “ooo,ooo”, 模式”o+?”匹配单个”o”共6个, 而”o+”匹配得到两个”ooo”</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">.</code></td>
      <td>匹配除”\n”以外的任意字符</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">x|y</code></td>
      <td>匹配x或y</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">\b</code></td>
      <td>匹配单词边界-bound</td>
      <td>“er\b”可以匹配”hacker”中的er，不能匹配”verb”中的er</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\B</code></td>
      <td>匹配非单词边界</td>
      <td>“er\b”可以匹配”verb”中的er，不能匹配”hacker”中的er</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\d</code></td>
      <td>匹配一个数字字符-digit</td>
      <td>等价于[0-9]</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\D</code></td>
      <td>匹配一个非数字字符</td>
      <td>等价于[^0-9]</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\s</code></td>
      <td>匹配一个任意的空白字符-space</td>
      <td>等价于[\f\n\r\t\v] (按顺序分为换页符, 换行, 回车, 制表符, 垂直制表符)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\w</code></td>
      <td>匹配一个包括下划线的任意单词字符-word</td>
      <td>等价于[A-Za-z0-9_] 注意包含<strong>下划线</strong></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\W</code></td>
      <td>匹配任何非单词字符</td>
      <td>[^A-Za-z0-9_]</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">\*num*</code></td>
      <td>正整数<em>num</em>表示第几个分组的引用</td>
      <td>如<code class="highlighter-rouge">(s)-(a)-\2</code>匹配”s-a-a”，<code class="highlighter-rouge">\1</code>得到第一个分组,这里是”s”,<code class="highlighter-rouge">\2</code>是第二个分组)</td>
    </tr>
  </tbody>
</table>

<h3 id="获取分组">获取分组</h3>

<p>使用小括号捕获分组, 自左向右, 第一个分组为1, 第二个为2, 以此类推</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">(pattern)</code></td>
      <td>匹配并捕获这一分组，之后可以通过<code class="highlighter-rouge">$num</code>引用,若有嵌套, 则按照左括号出现的顺序捕获</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">(?:pattern)</code></td>
      <td>匹配但不捕获</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">(?&lt;name&gt;pt)</code></td>
      <td>给分组命名,用<code class="highlighter-rouge">\k&lt;name&gt;</code>在模式中引用, 例如用<code class="highlighter-rouge">(?&lt;myword&gt;\w)\k&lt;myword&gt;</code>捕获两个连续的单词字符</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">(?=pattern)</code></td>
      <td>正向预查, <code class="highlighter-rouge">pattern</code>部分不在匹配范围内 <br /> 如<code class="highlighter-rouge">Java(?=6)</code>匹配”Java6, Java8”中的第一个”Java”, 不包含”6”</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">(?!pattern)</code></td>
      <td>正向否定预查</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">(?&lt;=pattern)</code></td>
      <td>反向预查 <br /> <code class="highlighter-rouge">(?&lt;=J)a</code>匹配”Java6, Java7”的结果为J<code class="highlighter-rouge">a</code>va6, J<code class="highlighter-rouge">a</code>va7</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">(?&lt;!pattern)</code></td>
      <td>反向否定预查</td>
    </tr>
  </tbody>
</table>

<mute>正/反向预查部分例子来自于&lt;https://my.oschina.net/lxpan/blog/27907&gt;</mute>

<p>Q: 为什么要使用<code class="highlighter-rouge">(?:pattern)</code>匹配但是不捕获分组? <br />
……为什么呢? 是不是存在可以不捕获但是必须分组的情况? 那么这种情况下就算捕获了会出现什么影响呢?</p>

<p><a href="1">这里</a>说捕获组是要占用内存的。那么答案应该是为了节省内存降低开销吧。</p>

<table>
  <thead>
    <tr>
      <th>Class Matcher Method</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">String</code></td>
      <td><code class="highlighter-rouge">group(int group)</code> <br />  Returns the input subsequence captured by the given group during the previous match operation.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">String</code></td>
      <td><code class="highlighter-rouge">group(String name)</code> <br />  Returns the input subsequence captured by the given named-capturing group during the previous match operation.</td>
    </tr>
  </tbody>
</table>

<p>补充：使用Java进行验证的时候，从API可以看出，每个捕获分组都对应一个String，验证了上述说法。</p>

<hr />

<blockquote>
  <p><del>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</del></p>
</blockquote>

<p>对于文本</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>一段时间没用连之前自己写的匹配模式都看不懂了
</pre></td></tr></tbody></table></code></pre></div></div>

<p>模式<code class="highlighter-rouge">一段(.*)连(.*)匹配(.*)(?&lt;n1&gt;懂)(.*)</code>匹配得到<code class="highlighter-rouge">一段时间没用连之前自己写的匹配模式都看不懂了</code></p>

<p>$1为<code class="highlighter-rouge">"时间没用"</code>, $2为<code class="highlighter-rouge">"之前自己写的"</code>, $3为<code class="highlighter-rouge">"模式都看不"</code>, $4为<code class="highlighter-rouge">"懂"</code>（与$&lt;n1&gt;相同。Java中获取命名分组使用<code class="highlighter-rouge">String group(String name)</code>, 获取分组数<code class="highlighter-rouge">groupCount()</code>），$5为<code class="highlighter-rouge">"了"</code>。与上面说法<strong>不符</strong></p>

<h4 id="嵌套分组捕获">嵌套分组捕获</h4>

<p>前面说了，嵌套是按照左括号从左到右出现的先后来捕获的，下面是示例：</p>

<p>对于文本</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>a1a2ba2  
a1a2ba1  
a1a2ba1a2  
a1a2ba1a2b  
</pre></td></tr></tbody></table></code></pre></div></div>

<p>模式<code class="highlighter-rouge">((a1(a2))b)\1</code>匹配第4行<code class="highlighter-rouge">a1a2ba1a2b</code><br />
模式<code class="highlighter-rouge">((a1(a2))b)\2</code>匹配第3、4行的<code class="highlighter-rouge">a1a2ba1a2</code><br />
模式<code class="highlighter-rouge">((a1(a2))b)\3</code>匹配第1行<code class="highlighter-rouge">a1a2ba2</code></p>

:ET